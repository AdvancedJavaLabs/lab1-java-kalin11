package org.itmo;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicBoolean;

class Graph {
    private final int V;
    private final List<Integer>[] adjList;

    public Graph(int vertices) {
        this.V = vertices;
        this.adjList = new ArrayList[vertices];
        for (int i = 0; i < vertices; i++) {
            adjList[i] = new ArrayList<>();
        }
    }

    public void addEdge(int src, int dest) {
        if (!adjList[src].contains(dest)) {
            adjList[src].add(dest);
        }
    }

    public void parallelBFS(int startVertex, int threadsCount) {
        Queue<Integer> currentLevelQueue = new ConcurrentLinkedQueue<>();
        ExecutorService executor = Executors.newFixedThreadPool(threadsCount);
        List<AtomicBoolean> visited = new ArrayList<>(V);
        for (int i = 0; i < V; i++) {
            visited.add(new AtomicBoolean(false));
        }

        visited.get(startVertex).set(true);

        currentLevelQueue.add(startVertex);

        try {
            while (!currentLevelQueue.isEmpty()) {
                Queue<Integer> nextLevelQueue = new ConcurrentLinkedQueue<>();
                List<Future<?>> currentLevelFutures = new ArrayList<>();

                while (!currentLevelQueue.isEmpty()) {
                    int currentVertex = currentLevelQueue.poll();
                    currentLevelFutures.add(executor.submit(() -> {
                        for (int child : adjList[currentVertex]) {
                            visitVertex(visited, child, nextLevelQueue);
                        }
                    }));
                }

                for (Future<?> future : currentLevelFutures) {
                    try {
                        future.get();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }

                currentLevelQueue = nextLevelQueue;
            }
        } finally {
            executor.shutdown();
        }
    }

    private void visitVertex(
            List<AtomicBoolean> visited,
            int currentVertex,
            Queue<Integer> nextLevelQueue
    ) {
        if (!visited.get(currentVertex).get()) {
            visited.get(currentVertex).set(true);
            nextLevelQueue.add(currentVertex);
        }
    }

    //Generated by ChatGPT
    public void bfs(int startVertex) {
        boolean[] visited = new boolean[V];

        LinkedList<Integer> queue = new LinkedList<>();

        visited[startVertex] = true;
        queue.add(startVertex);

        while (!queue.isEmpty()) {
            startVertex = queue.poll();

            for (int n : adjList[startVertex]) {
                if (!visited[n]) {
                    visited[n] = true;
                    queue.add(n);
                }
            }
        }
    }

}
