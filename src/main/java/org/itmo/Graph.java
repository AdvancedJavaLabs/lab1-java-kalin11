package org.itmo;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Collectors;

public class Graph {
    private static final int BATCH_SIZE = 10_000;

    private final int verticesCount;
    private final List<List<Integer>> adjList;

    private final ExecutorService executor;

    public Graph(int vertices) {
        this.verticesCount = vertices;
        this.adjList = new ArrayList<>();
        for (int i = 0; i < vertices; i++) {
            adjList.add(new ArrayList<>());
        }
        this.executor = Executors.newFixedThreadPool(8);
    }

    public void addEdge(int src, int dest) {
        if (!adjList.get(src).contains(dest)) {
            adjList.get(src).add(dest);
        }
    }

    public void parallelBFS(int startVertex) {
        List<AtomicBoolean> visited = new ArrayList<>();

        for (int i = 0; i < verticesCount; i++) {
            visited.add(new AtomicBoolean(false));
        }
        visited.get(startVertex).set(true);

        List<Integer> currentLevel = new ArrayList<>();
        currentLevel.add(startVertex);

        try {
            while (!currentLevel.isEmpty()) {
                List<List<Integer>> nextLevelSubLists = Collections.synchronizedList(new ArrayList<>());
                List<Callable<Void>> tasks = new ArrayList<>();

                for (int from = 0; from < currentLevel.size(); from += BATCH_SIZE) {
                    int to = Math.min(from + BATCH_SIZE, currentLevel.size());
                    List<Integer> batch = currentLevel.subList(from, to);

                    tasks.add(() -> {
                        List<Integer> nextLevelFromBatch = new ArrayList<>();
                        for (int vertex : batch) {
                            for (int child : adjList.get(vertex)) {
                                if (visited.get(child).compareAndSet(false, true)) {
                                    nextLevelFromBatch.add(child);
                                }
                            }
                        }
                        nextLevelSubLists.add(nextLevelFromBatch);
                        return null;
                    });
                }

                executor.invokeAll(tasks);

                currentLevel = nextLevelSubLists.stream()
                        .flatMap(List::stream)
                        .collect(Collectors.toList());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            executor.shutdown();
        }
    }

    //Generated by ChatGPT
    public void bfs(int startVertex) {
        boolean[] visited = new boolean[verticesCount];

        LinkedList<Integer> queue = new LinkedList<>();

        visited[startVertex] = true;
        queue.add(startVertex);

        while (!queue.isEmpty()) {
            startVertex = queue.poll();

            for (int n : adjList.get(startVertex)) {
                if (!visited[n]) {
                    visited[n] = true;
                    queue.add(n);
                }
            }
        }
    }

    public List<List<Integer>> getAdjList() {
        return adjList;
    }

    public ExecutorService getExecutor() {
        return executor;
    }
}
